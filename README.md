## General flow of the program

* In order to implement the current project, I have used several classes, each serving a specific purpose.
* After every command given, the program identifies the user and gives result specific to that user.
* Every result is saved in a field specific to the user, thus after multiple searches/loads/etc. the results of each user will be independent of each other.
* When a command is made, it is sent to the specific command class, and then it is processed
* The effects are visible in the user instance that gave the command, but also in the entire library(if the command creates a public playlist)
* After every command, the result is generated by the specific output command class that has a method specialized in creating JSON files


## Classes' description and interactions
* `Command`: is the template class for all commands given to the program
* `CommandOutput`: is the template for all the output results, based on the given command
* `AudioFile`: is an interface used for designing different audiofiles such as songs
* `Library`
  * the main class of the program, that contains all the information about the library, and also the methods that are used to manipulate the library
  * it contains a list of users, a list of songs, a list of playlists, and a list of artists

* `User`
    * the class that contains all the information about a user
    * it contains a list of playlists, a list of songs, and a list of artists
    * it also contains a list of notifications, that are used to notify the user when a song is uploaded by an artist that he follows
    * in the program, we use different types of users, that are subclasses of the User class, as follows:
        * `Artist` - a user that can upload songs, and can be followed by other users
        * `Host` - a user that can create playlists, and can be followed by other users
    * the user class also implements the `Subscriber` interface, in order to be notified when a song is uploaded by an artist that he follows

## Wrapped implementation

* each time an audiofile(song/episode) is listened in the program, a new entry is added to that file's history
* the program manages the user that listened to the file, but also the timestamp of the listen, in order to differentiate between the listens

## Monetization system

### Premium monetizaton

* a field in the user class is used to store the premium status of the user
* each song contains a field that stores the number of times it was listened by premium users, while they were premium
* similar to the wrapped command, a hashmap is used to store the number of listens of a song by a premium user
* at the end of the user's premium status, the number of listens is added to the total number of listens of the song and monetized accordingly

### Advertisement monetization

* in order to store the ad and the song it is attached to, each song contains a hashset with the users that have an ad attached to that song
* in the `Player` object, each time a song is played, the `pass()` method is called, that checks if the song has an ad attached to it, and if so, it monetizes all listed songs by that user
* in order to monetize each listen only once, the `Library` instance contains a record of all listens, by taking advantage of the `ListenedEntry` class - containing the song, user and the timestamp of the listen

## Design patterns
* `Singleton` - used for the Library class, in order to have only one instance of the library, that would be accessible from anywhere in the program
* `Factory` - used for the creation of the commands, in order to have a single point of creation for all commands
* `Observer` - used for the implementation of the notification system, in order to notify the users at the right time
* `Builder` - used for the creation of the output results for the wrapped commands

### Other observations
* the program runs with 100 points on the local grader, but fails on vmchecker on one test
